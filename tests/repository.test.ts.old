import { CreateTaskDto, UpdateTaskDto } from '../types/task';

// Mock the pool module
jest.mock('../src/db/pool', () => ({
  __esModule: true,
  default: {
    query: jest.fn(),
  },
}));

interface MockQueryResult {
  rows: unknown[];
  rowCount: number;
}

describe('Repository', () => {
  let repository: typeof import('../src/db/repository');
  let pool: typeof import('../src/db/pool').default;
  let mockPool: jest.Mocked<typeof import('../src/db/pool').default>;

  beforeAll(async () => {
    // Import after mocking
    pool = (await import('../src/db/pool')).default;
    repository = await import('../src/db/repository');
    mockPool = pool as jest.Mocked<typeof pool>;
  });

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Task Operations', () => {
    describe('createTask', () => {
      it('should create a task with minimum required fields', async () => {
        const mockTask = {
          id: 'task-1',
          title: 'Test Task',
          description: null,
          status: 'PENDING',
          priority: 'MEDIUM',
          due_date: null,
          project_id: null,
          created_at: new Date(),
          updated_at: new Date(),
        };

        mockPool.query
          .mockResolvedValueOnce({ rows: [mockTask], rowCount: 1 } as any)
          .mockResolvedValueOnce({ rows: [], rowCount: 1 } as any);

        const taskData: CreateTaskDto = {
          title: 'Test Task',
        };

        let result;
        try {
          result = await repository.createTask('user-1', taskData);
          console.log('Result:', result);
        } catch (error) {
          console.error('Error in createTask:', error);
          throw error;
        }

        expect(mockPool.query).toHaveBeenCalledTimes(2);
        expect(mockPool.query).toHaveBeenNthCalledWith(
          1,
          expect.stringContaining('INSERT INTO tasks'),
          [null, 'Test Task', null, 'PENDING', 'MEDIUM', null],
        );
        expect(mockPool.query).toHaveBeenNthCalledWith(
          2,
          'INSERT INTO task_assignments (task_id, user_id) VALUES ($1, $2)',
          ['task-1', 'user-1'],
        );
        expect(result).toEqual(mockTask);
      });

      it('should create a task with all fields provided', async () => {
        const mockTask = {
          id: 'task-2',
          title: 'Complete Task',
          description: 'Task description',
          status: 'IN_PROGRESS',
          priority: 'HIGH',
          due_date: new Date('2023-12-31'),
          project_id: 'project-1',
          created_at: new Date(),
          updated_at: new Date(),
        };

        mockPool.query
          .mockResolvedValueOnce({ rows: [mockTask], rowCount: 1 } as any)
          .mockResolvedValueOnce({ rows: [], rowCount: 1 } as any);

        const taskData: CreateTaskDto = {
          title: 'Complete Task',
          description: 'Task description',
          status: 'IN_PROGRESS',
          priority: 'HIGH',
          due_date: new Date('2023-12-31'),
          project_id: 'project-1',
        };

        const result = await repository.createTask('user-1', taskData);

        expect(mockPool.query).toHaveBeenNthCalledWith(
          1,
          expect.stringContaining('INSERT INTO tasks'),
          [
            'project-1',
            'Complete Task',
            'Task description',
            'IN_PROGRESS',
            'HIGH',
            new Date('2023-12-31'),
          ],
        );
        expect(result).toEqual(mockTask);
      });
    });

    describe('getTasks', () => {
      it('should return tasks for a user', async () => {
        const mockTasks = [
          { id: 'task-1', title: 'Task 1', status: 'PENDING' },
          { id: 'task-2', title: 'Task 2', status: 'COMPLETED' },
        ];

        mockPool.query.mockResolvedValue({ rows: mockTasks, rowCount: 2 } as any);

        const result = await repository.getTasks('user-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('SELECT t.* FROM tasks t'),
          ['user-1'],
        );
        expect(result).toEqual(mockTasks);
      });

      it('should return empty array when user has no tasks', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getTasks('user-1');

        expect(result).toEqual([]);
      });
    });

    describe('getTaskById', () => {
      it('should return a task when found', async () => {
        const mockTask = { id: 'task-1', title: 'Task 1', status: 'PENDING' };
        mockPool.query.mockResolvedValue({ rows: [mockTask], rowCount: 1 } as any);

        const result = await repository.getTaskById('user-1', 'task-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('SELECT t.* FROM tasks t'),
          ['user-1', 'task-1'],
        );
        expect(result).toEqual(mockTask);
      });

      it('should return null when task not found', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getTaskById('user-1', 'nonexistent');

        expect(result).toBeNull();
      });
    });

    describe('updateTask', () => {
      it('should update task with single field', async () => {
        const mockUpdatedTask = { id: 'task-1', title: 'Updated Task', status: 'PENDING' };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedTask], rowCount: 1 } as any);

        const updates: UpdateTaskDto = { title: 'Updated Task' };
        const result = await repository.updateTask('user-1', 'task-1', updates);

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(/UPDATE tasks SET title = \$1, updated_at = \$2/),
          expect.arrayContaining(['Updated Task', expect.any(Date), 'task-1', 'user-1']),
        );
        expect(result).toEqual(mockUpdatedTask);
      });

      it('should update task with multiple fields', async () => {
        const mockUpdatedTask = {
          id: 'task-1',
          title: 'Updated Task',
          status: 'COMPLETED',
          priority: 'HIGH',
        };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedTask], rowCount: 1 } as any);

        const updates: UpdateTaskDto = {
          title: 'Updated Task',
          status: 'COMPLETED',
          priority: 'HIGH',
        };
        const result = await repository.updateTask('user-1', 'task-1', updates);

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(
            /UPDATE tasks SET.*title = \$1.*status = \$2.*priority = \$3.*updated_at = \$4/,
          ),
          expect.arrayContaining([
            'Updated Task',
            'COMPLETED',
            'HIGH',
            expect.any(Date),
            'task-1',
            'user-1',
          ]),
        );
        expect(result).toEqual(mockUpdatedTask);
      });

      it('should return null when no fields to update', async () => {
        const result = await repository.updateTask('user-1', 'task-1', {});

        expect(mockPool.query).not.toHaveBeenCalled();
        expect(result).toBeNull();
      });

      it('should return null when task not found or not owned by user', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const updates: UpdateTaskDto = { title: 'Updated Task' };
        const result = await repository.updateTask('user-1', 'task-1', updates);

        expect(result).toBeNull();
      });

      it('should ignore undefined values in updates', async () => {
        const mockUpdatedTask = { id: 'task-1', title: 'Updated Task' };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedTask], rowCount: 1 } as any);

        const updates: UpdateTaskDto = {
          title: 'Updated Task',
          status: undefined,
          description: undefined,
        };
        const result = await repository.updateTask('user-1', 'task-1', updates);

        // Should only include title in the update, not the undefined values
        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(/UPDATE tasks SET title = \$1, updated_at = \$2/),
          expect.arrayContaining(['Updated Task', expect.any(Date), 'task-1', 'user-1']),
        );
        expect(result).toEqual(mockUpdatedTask);
      });
    });

    describe('deleteTask', () => {
      it('should delete task successfully', async () => {
        mockPool.query.mockResolvedValue({ rows: [{ id: 'task-1' }], rowCount: 1 } as any);

        const result = await repository.deleteTask('user-1', 'task-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('DELETE FROM tasks WHERE id = $1'),
          ['task-1', 'user-1'],
        );
        expect(result).toBe(true);
      });

      it('should return false when task not found or not owned by user', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.deleteTask('user-1', 'task-1');

        expect(result).toBe(false);
      });
    });

    describe('getTasksByFilter', () => {
      it('should get tasks with no filters', async () => {
        const mockTasks = [{ id: 'task-1', title: 'Task 1' }];
        mockPool.query.mockResolvedValue({ rows: mockTasks, rowCount: 1 } as any);

        const result = await repository.getTasksByFilter('user-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('WHERE ta.user_id = $1'),
          ['user-1'],
        );
        expect(result).toEqual(mockTasks);
      });

      it('should get tasks filtered by project', async () => {
        const mockTasks = [{ id: 'task-1', title: 'Task 1', project_id: 'project-1' }];
        mockPool.query.mockResolvedValue({ rows: mockTasks, rowCount: 1 } as any);

        const result = await repository.getTasksByFilter('user-1', 'project-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('WHERE ta.user_id = $1 AND t.project_id = $2'),
          ['user-1', 'project-1'],
        );
        expect(result).toEqual(mockTasks);
      });

      it('should get tasks filtered by status', async () => {
        const mockTasks = [{ id: 'task-1', title: 'Task 1', status: 'PENDING' }];
        mockPool.query.mockResolvedValue({ rows: mockTasks, rowCount: 1 } as any);

        const result = await repository.getTasksByFilter('user-1', undefined, 'PENDING');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('WHERE ta.user_id = $1 AND t.status = $2'),
          ['user-1', 'PENDING'],
        );
        expect(result).toEqual(mockTasks);
      });

      it('should get tasks filtered by both project and status', async () => {
        const mockTasks = [
          { id: 'task-1', title: 'Task 1', project_id: 'project-1', status: 'PENDING' },
        ];
        mockPool.query.mockResolvedValue({ rows: mockTasks, rowCount: 1 } as any);

        const result = await repository.getTasksByFilter('user-1', 'project-1', 'PENDING');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('WHERE ta.user_id = $1 AND t.project_id = $2 AND t.status = $3'),
          ['user-1', 'project-1', 'PENDING'],
        );
        expect(result).toEqual(mockTasks);
      });
    });
  });

  describe('User Operations', () => {
    describe('createUser', () => {
      it('should create user with name', async () => {
        const mockUser = { id: 'user-1', email: 'test@example.com', name: 'Test User' };
        mockPool.query.mockResolvedValue({ rows: [mockUser], rowCount: 1 } as any);

        const result = await repository.createUser(
          'test@example.com',
          'hashedpassword',
          'Test User',
        );

        expect(mockPool.query).toHaveBeenCalledWith(
          'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name',
          ['test@example.com', 'hashedpassword', 'Test User'],
        );
        expect(result).toEqual(mockUser);
      });

      it('should create user without name', async () => {
        const mockUser = { id: 'user-1', email: 'test@example.com', name: null };
        mockPool.query.mockResolvedValue({ rows: [mockUser], rowCount: 1 } as any);

        const result = await repository.createUser('test@example.com', 'hashedpassword');

        expect(mockPool.query).toHaveBeenCalledWith(
          'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name',
          ['test@example.com', 'hashedpassword', undefined],
        );
        expect(result).toEqual(mockUser);
      });
    });

    describe('getUserByEmail', () => {
      it('should return user when found', async () => {
        const mockUser = {
          id: 'user-1',
          email: 'test@example.com',
          name: 'Test User',
          password_hash: 'hashed',
        };
        mockPool.query.mockResolvedValue({ rows: [mockUser], rowCount: 1 } as any);

        const result = await repository.getUserByEmail('test@example.com');

        expect(mockPool.query).toHaveBeenCalledWith(
          'SELECT id, email, name, password_hash FROM users WHERE email = $1',
          ['test@example.com'],
        );
        expect(result).toEqual(mockUser);
      });

      it('should return null when user not found', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getUserByEmail('nonexistent@example.com');

        expect(result).toBeNull();
      });
    });

    describe('getUserById', () => {
      it('should return user when found', async () => {
        const mockUser = { id: 'user-1', email: 'test@example.com', name: 'Test User' };
        mockPool.query.mockResolvedValue({ rows: [mockUser], rowCount: 1 } as any);

        const result = await repository.getUserById('user-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          'SELECT id, email, name FROM users WHERE id = $1',
          ['user-1'],
        );
        expect(result).toEqual(mockUser);
      });

      it('should return null when user not found', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getUserById('nonexistent');

        expect(result).toBeNull();
      });
    });
  });

  describe('Project Operations', () => {
    describe('createProject', () => {
      it('should create project with description', async () => {
        const mockProject = {
          id: 'project-1',
          name: 'Test Project',
          description: 'Project description',
          owner_id: 'user-1',
        };
        mockPool.query.mockResolvedValue({ rows: [mockProject], rowCount: 1 } as any);

        const result = await repository.createProject(
          'user-1',
          'Test Project',
          'Project description',
        );

        expect(mockPool.query).toHaveBeenCalledWith(
          'INSERT INTO projects (owner_id, name, description) VALUES ($1, $2, $3) RETURNING *',
          ['user-1', 'Test Project', 'Project description'],
        );
        expect(result).toEqual(mockProject);
      });

      it('should create project without description', async () => {
        const mockProject = {
          id: 'project-1',
          name: 'Test Project',
          description: null,
          owner_id: 'user-1',
        };
        mockPool.query.mockResolvedValue({ rows: [mockProject], rowCount: 1 } as any);

        const result = await repository.createProject('user-1', 'Test Project');

        expect(mockPool.query).toHaveBeenCalledWith(
          'INSERT INTO projects (owner_id, name, description) VALUES ($1, $2, $3) RETURNING *',
          ['user-1', 'Test Project', undefined],
        );
        expect(result).toEqual(mockProject);
      });
    });

    describe('getProjectsForOwner', () => {
      it('should return projects for owner', async () => {
        const mockProjects = [
          { id: 'project-1', name: 'Project 1', owner_id: 'user-1' },
          { id: 'project-2', name: 'Project 2', owner_id: 'user-1' },
        ];
        mockPool.query.mockResolvedValue({ rows: mockProjects, rowCount: 2 } as any);

        const result = await repository.getProjectsForOwner('user-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          'SELECT * FROM projects WHERE owner_id = $1 ORDER BY created_at DESC',
          ['user-1'],
        );
        expect(result).toEqual(mockProjects);
      });

      it('should return empty array when owner has no projects', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getProjectsForOwner('user-1');

        expect(result).toEqual([]);
      });
    });

    describe('getProjectById', () => {
      it('should return project when found and owned by user', async () => {
        const mockProject = { id: 'project-1', name: 'Project 1', owner_id: 'user-1' };
        mockPool.query.mockResolvedValue({ rows: [mockProject], rowCount: 1 } as any);

        const result = await repository.getProjectById('user-1', 'project-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          'SELECT * FROM projects WHERE id = $1 AND owner_id = $2',
          ['project-1', 'user-1'],
        );
        expect(result).toEqual(mockProject);
      });

      it('should return null when project not found or not owned by user', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getProjectById('user-1', 'project-1');

        expect(result).toBeNull();
      });
    });

    describe('updateProject', () => {
      it('should update project with single field', async () => {
        const mockUpdatedProject = { id: 'project-1', name: 'Updated Project', owner_id: 'user-1' };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedProject], rowCount: 1 } as any);

        const result = await repository.updateProject('user-1', 'project-1', {
          name: 'Updated Project',
        });

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(/UPDATE projects SET name = \$1, updated_at = \$2/),
          expect.arrayContaining(['Updated Project', expect.any(Date), 'project-1', 'user-1']),
        );
        expect(result).toEqual(mockUpdatedProject);
      });

      it('should update project with multiple fields', async () => {
        const mockUpdatedProject = {
          id: 'project-1',
          name: 'Updated Project',
          description: 'Updated description',
          owner_id: 'user-1',
        };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedProject], rowCount: 1 } as any);

        const result = await repository.updateProject('user-1', 'project-1', {
          name: 'Updated Project',
          description: 'Updated description',
        });

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(
            /UPDATE projects SET.*name = \$1.*description = \$2.*updated_at = \$3/,
          ),
          expect.arrayContaining([
            'Updated Project',
            'Updated description',
            expect.any(Date),
            'project-1',
            'user-1',
          ]),
        );
        expect(result).toEqual(mockUpdatedProject);
      });

      it('should return null when no fields to update', async () => {
        const result = await repository.updateProject('user-1', 'project-1', {});

        expect(mockPool.query).not.toHaveBeenCalled();
        expect(result).toBeNull();
      });

      it('should return null when project not found or not owned by user', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.updateProject('user-1', 'project-1', {
          name: 'Updated Project',
        });

        expect(result).toBeNull();
      });

      it('should ignore undefined values in updates', async () => {
        const mockUpdatedProject = { id: 'project-1', name: 'Updated Project', owner_id: 'user-1' };
        mockPool.query.mockResolvedValue({ rows: [mockUpdatedProject], rowCount: 1 } as any);

        const result = await repository.updateProject('user-1', 'project-1', {
          name: 'Updated Project',
          description: undefined,
        });

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringMatching(/UPDATE projects SET name = \$1, updated_at = \$2/),
          expect.arrayContaining(['Updated Project', expect.any(Date), 'project-1', 'user-1']),
        );
        expect(result).toEqual(mockUpdatedProject);
      });
    });

    describe('deleteProject', () => {
      it('should delete project successfully', async () => {
        mockPool.query.mockResolvedValue({ rows: [{ id: 'project-1' }], rowCount: 1 } as any);

        const result = await repository.deleteProject('user-1', 'project-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          'DELETE FROM projects WHERE id = $1 AND owner_id = $2 RETURNING id',
          ['project-1', 'user-1'],
        );
        expect(result).toBe(true);
      });

      it('should return false when project not found or not owned by user', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.deleteProject('user-1', 'project-1');

        expect(result).toBe(false);
      });
    });

    describe('getProjectStats', () => {
      it('should return project statistics', async () => {
        const mockStatsData = [
          { status: 'PENDING', count: '3' },
          { status: 'IN_PROGRESS', count: '2' },
          { status: 'COMPLETED', count: '5' },
        ];
        mockPool.query.mockResolvedValue({ rows: mockStatsData, rowCount: 3 } as any);

        const result = await repository.getProjectStats('user-1', 'project-1');

        expect(mockPool.query).toHaveBeenCalledWith(
          expect.stringContaining('SELECT t.status, COUNT(*)::int AS count'),
          ['project-1', 'user-1'],
        );
        expect(result).toEqual({
          PENDING: 3,
          IN_PROGRESS: 2,
          COMPLETED: 5,
        });
      });

      it('should return default counts when no tasks exist', async () => {
        mockPool.query.mockResolvedValue({ rows: [], rowCount: 0 } as any);

        const result = await repository.getProjectStats('user-1', 'project-1');

        expect(result).toEqual({
          PENDING: 0,
          IN_PROGRESS: 0,
          COMPLETED: 0,
        });
      });

      it('should handle partial statistics', async () => {
        const mockStatsData = [
          { status: 'PENDING', count: '2' },
          { status: 'COMPLETED', count: '1' },
        ];
        mockPool.query.mockResolvedValue({ rows: mockStatsData, rowCount: 2 } as any);

        const result = await repository.getProjectStats('user-1', 'project-1');

        expect(result).toEqual({
          PENDING: 2,
          IN_PROGRESS: 0,
          COMPLETED: 1,
        });
      });
    });
  });
});
